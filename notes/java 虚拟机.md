# 运行时数据区

![](./img/mem.png)

## 程序计数器

记录正在运行的jvm指令的地址，如果执行是本地方法，则为空

## 栈

一个线程对应一个虚拟机栈，线程中每一个方法执行会创建一个栈帧，栈帧记录局部变量表，动态连接(符号引用的转换为直接引用)，操作数栈等信息；

方法的调用到执行完成的过程，对应着栈帧在栈中入栈到出栈的过程

- -Xss 参数指定栈帧大小
- stackOverError ,线程请求的栈深度超过最大值
- outOfMemoryError, 栈进行动态扩展时无法申请到内存；堆空间溢出



## 堆

存放对象，垃圾回收的主要场所，分为年轻代、老年代，为了使用分代垃圾回收的目的

## 方法区

方法区是一种理论设计，具体实现不同（1.7 -- 永久代，1.8 --元空间）

保存类信息，常量，静态变量，1.8中，方法区被分成了两部分，堆和元空间，元空间位于本地内存，存放类信息。

## 运行时常量池

是方法区的一部分，存放编译生成的常量，动态加入的常量(String.intern),符号引用。常量池依然会内存溢出

# 垃圾回收

垃圾回收主要针对堆和运行时常量池

## 判断对象是否可以回收

java采用可达性分析来判断对象是否存活

可达性分析：以GC ROOT为起点进行搜索(引用链)，能搜索到的都是存活的，否则需要回收

GC ROOT  

- 局部变量表中引用的对象
- 本地方法栈中引用的对象
- 方法区静态属性引用的对象
- 方法区常量引用的对象

## 引用类型

- 强引用

  new  创建强引用，被强引用的对象不会被回收

- 弱引用

  使用WeakReference 创建弱引用，弱引用的对象会在下一次gc 时被回收

  ```java
  WeakReference<Apple> appleWeakReference = new WeakReference<>(apple);
  ```

- 软引用

  使用foftReference 创建软引用，被软引用的对象在内存不足时被回收

- 虚引用

  使用phantomReference 创建幽灵引用，唯一作用是在回收时受到系统通知

## 方法区的回收

主要是回收常量，对类的卸载



## 垃圾回收算法

1. 标记-清除，为未存活对象打上标记进行回收；会产生大量内存碎片，因为回收后得到的空间和以后分配对象的大小不匹配

2. 标记-整理，把存活的对象移动到内存另一端，然后直接清楚边界以外的内存；不会产生碎片，但需要移动对象，效率低

3. 复制，把内存化为两块，每次只使用其中一块；当这一块用完了，把存活对象复制到另外一块，然后清除本块区域。

   新生代回收的主流做法，不过不是分为相等的两块，而是分为较大的EDEN 和 两块 survivor ，每次使用eden 和一块survivor；回收时，把存活对象复制到未使用的survivor中，并清除掉使用过额 eden 和 survivor 。hotspot 使用 8:1:1的比例来分配，如果复制的时候survivor 不够，就会使用老年代的空间

4. 分代回收

   - 新生代 -- 复制
   - 老年代 -- 标记清除、标记整理

## 垃圾回收器

垃圾回收器主要分为

- 串行 / 并行
- 单线程/多线程

### G1回收器

g1 开创了以region 为单位的内存布局，把堆内存分为多个独立的区域 region，region可以根据需要，扮演eden 、survivor 或者老年代，分代成为一种概念上的东西。收集器能够更具不同角色的region 采用不同的收集策略。

1. G1采用的收集策略是估算每个region 的回收价值，维护一个优先级表，然后根据用户的期望停顿值，处理回收那些价值最大的region 区域。而必满了全域回收的方式
   - MaxGcPause 指定
2. 每个region 维护一个记忆集，用来记录跨region 引用的对象，这样在做可达性分析的时候就不需要全堆扫描，而是通过记忆集区搜寻

大致回收流程(cms流程大致相同，不过采用的是标记-清除算法)

1. 初始标记，标记于GC ROOT 直接关联的对象，需要短暂的停顿

2. 并发标记，从GC ROOT开始进行可达性分析，耗时长

3. 最终标记，处理并发标记时引用发生变动的对象

4. 筛选回收 -- 复制

   ![](./img/G1.jpg)



# 内存分配与回收策略

## 内存分配

- 新对象优先在eden 分配，如果空间满了，执行 minor gc
- 大对象直接进入老年代，大对象指需要较多连续空间的对象，同时避免在 eden 和 survivor 之间大量内存复制
- 长期存活的对象进入老年代，通过对象的年龄计数器
- 动态对象年龄判断，除了上一点，当相同年龄的对象和大于 survivor 一半的区域，就把大于或等于该年龄的对象放入老年代
- 空间分配担保

## FULL GC 触发条件

1. 老年代空间不足
2. 调用了system.gc
3. 空间担保失败，复制算法需要老年代有足够的连续空间保证年轻代的对象能放下



# 类加载机制

在运行期间，第一次访问类的时候，在会加载其信息，而不是程序一开始就全部加载

## 类的生命周期

![](./img/loadClass.png)

## 类加载过程

1. 加载

   加载包含三个步骤

   1. 通过全限定类名找到类的二进制字节流
      - 从压缩包中读取
      - 从网络中读取
      - 运行时计算出，场景--动态代理
      - 其他文件生成，场景--jsp
   2. 把静态存储结构转化为方法区中动态的存储结构
   3. 在内存中生存一个代表该类的class 对象，作为访问该类信息的入口

2. 验证

   检测类是否符合虚拟机规范、安全性等

3. 准备

   为静态变量分配内存，并设置初始化

4. 解析

   把常量池的符号引用替换为直接引用

   - 符号引用，用一个符号来描述引用的目标，和虚拟机内存布局没有关系
   - 直接引用，可以直接指向目标的指针或内存便宜量，和虚拟机内存布局相关，就是内存地址

5. 初始化

   真正开始执行类中的java代码，也就是执行类构造器clinit,clinit 整合了和静态变量相关的代码--也就是静态语句块和类变量的赋值

   - 静态语句块执行给出现之前的静态变量赋值

## 类初始化的触发

1. 主动引用

   1. new getStatic/putStatic invokeStatic -- 创建对象、读取或写入静态变量、调用静态方法
   2. 对类进行反射调用 -- java.lang.refect
   3. 当子类被加载的时候，会初始化当前类（父类）
   4. 虚拟机启动的时候，需要执行一个主类（包含main的类）
   5. 如果接口定义了默认方法，那么其实现类初始化之前，接口需要初始化

2. 被动引用

   被动引用不会出发类的初始化

   1. 调用父类的静态字段，子类不会初始化

   2. 数组定义引用类，不会出发类初始化，只会初始化数组类（虚拟机生成，继承Object，包含数组的属性和方法）

   3. 常量在编译阶段会放入调用类的常量池，所以并没有引用定义常量的类

      ```java
      // B.HELLO 被放入A常量池中
      public class A{
          A(){
              System.out.println(B.HELLO)
          }
      }
      ```



## 类与类加载器

类 与 类加载器 共同决定了一个类的唯一性；或者说 类是否相等 (intanceof,equals,isintance 等判定结果 )。比较两个类是否相同，必须是由同一个类加载器加载才能相同

## 类加载器

类加载器作用：如果获取类信息

分类

- 启动类加载器，目录 javahome/lib下的，能够被虚拟机识别的库
- 扩展类加载器， 目录javahome/lib/ext
- 应用程序类加载器，目录 用户类路径 classPath 的类库

### 双亲委派模型

![](./img/classLoader.png)

- 工作原理：类加载器收到了类加载的请求，它会把这个请求委派给父类先处理，处理不了，自己才处理

- 好处：双亲委派模型保证类加载机制具有优先级的层次关系，例如，rt包中的object ， 它最终只能有最顶层的加载器加载，这就保证了object的唯一性

